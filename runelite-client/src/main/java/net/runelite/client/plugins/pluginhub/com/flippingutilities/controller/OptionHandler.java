package net.runelite.client.plugins.pluginhub.com.flippingutilities.controller;

import net.runelite.client.plugins.pluginhub.com.flippingutilities.model.FlippingItem;
import net.runelite.client.plugins.pluginhub.com.flippingutilities.model.Option;
import net.runelite.client.plugins.pluginhub.com.flippingutilities.utilities.InvalidOptionException;
import net.runelite.client.plugins.pluginhub.com.flippingutilities.utilities.WikiItemMargins;
import net.runelite.client.plugins.pluginhub.com.flippingutilities.utilities.WikiRequest;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemStats;

import java.util.Optional;

public class OptionHandler {
    FlippingPlugin plugin;

    public OptionHandler(FlippingPlugin plugin) {
        this.plugin = plugin;
    }

    public int calculateOptionValue(Option option, Optional<FlippingItem> highlightedItem, int highlightedItemId) throws InvalidOptionException {
        int val = 0;
        String propertyString = option.getProperty();
        switch (propertyString) {
            case Option.GE_LIMIT:
                val = geLimitCalculation(highlightedItem, highlightedItemId);
                break;
            case Option.REMAINING_LIMIT:
                val = remainingGeLimitCalculation(highlightedItem, highlightedItemId);
                break;
            case Option.CASHSTACK:
                val = cashStackCalculation(highlightedItem, highlightedItemId);
                break;
            case Option.INSTA_SELL:
                val = instaSellCalculation(highlightedItem);
                break;
            case Option.INSTA_BUY:
                val = instaBuyCalculation(highlightedItem);
                break;
            case Option.LAST_BUY:
                val = latestBuyCalculation(highlightedItem);
                break;
            case Option.LAST_SELL:
                val = latestSellCalculation(highlightedItem);
                break;
            case Option.WIKI_BUY:
                val = wikiPriceCalculation(highlightedItemId, true);
                break;
            case Option.WIKI_SELL:
                val = wikiPriceCalculation(highlightedItemId, false);
                break;
        }

        int finalValue = applyModifier(option.getModifier(), val);
        if (finalValue < 0) {
            throw new InvalidOptionException("resulting value was negative");
        }
        return finalValue;
    }

    private int wikiPriceCalculation(int itemId, boolean getBuyPrice) throws InvalidOptionException {
        if (plugin.getLastWikiRequestWrapper() != null) {
            WikiRequest wr = plugin.getLastWikiRequestWrapper().getWikiRequest();
            WikiItemMargins wikiItemMargins = wr.getData().get(itemId);
            int wikiPrice = getBuyPrice ? wikiItemMargins.getHigh() : wikiItemMargins.getLow();
            if (wikiPrice == 0) {
                throw new InvalidOptionException(String.format("no insta %s data for this item", getBuyPrice ? "buy" : "sell"));
            }
            return wikiPrice;
        } else {
            throw new InvalidOptionException("wiki request has not been made yet");
        }
    }

    private int remainingGeLimitCalculation(Optional<FlippingItem> item, int itemId) throws InvalidOptionException {
        ItemStats itemStats = plugin.getItemManager().getItemStats(itemId);
        int geLimit = itemStats != null ? itemStats.getGeLimit() : 0;
        int totalGeLimit = item.map(FlippingItem::getTotalGELimit).orElse(geLimit);
        if (totalGeLimit <= 0) {
            throw new InvalidOptionException("Item does not have a known limit. Cannot calculate resulting value");
        }
        return item.map(FlippingItem::getRemainingGeLimit).orElse(geLimit);
    }

    private int geLimitCalculation(Optional<FlippingItem> item, int itemId) throws InvalidOptionException {
        ItemStats itemStats = plugin.getItemManager().getItemStats(itemId);
        int geLimit = itemStats != null ? itemStats.getGeLimit() : 0;
        int totalGeLimit = item.map(FlippingItem::getTotalGELimit).orElse(geLimit);
        if (totalGeLimit <= 0) {
            throw new InvalidOptionException("Item does not have a known limit. Cannot calculate resulting value");
        }
        return item.map(FlippingItem::getTotalGELimit).orElse(geLimit);
    }

    private int cashStackCalculation(Optional<FlippingItem> item, int itemId) throws InvalidOptionException {
        if (getCashStackInInv() == 0) {
            throw new InvalidOptionException("Player has no cash in inventory");
        }
        int offerPrice = plugin.getClient().getVarbitValue(VarbitID.GE_NEWOFFER_PRICE);
        if (offerPrice <= 0) {
            throw new InvalidOptionException("Item offer price missing");
        }

        return getCashStackInInv() / offerPrice;
    }

    private int instaBuyCalculation(Optional<FlippingItem> item) throws InvalidOptionException {
        if (!item.isPresent()) {
            throw new InvalidOptionException("item was not bought or sold");
        } else {
            if (item.get().getLatestInstaBuy().isPresent()) {
                return item.get().getLatestInstaBuy().get().getPrice();
            } else {
                throw new InvalidOptionException("item does not have an insta buy price");
            }
        }
    }

    private int instaSellCalculation(Optional<FlippingItem> item) throws InvalidOptionException {
        if (!item.isPresent()) {
            throw new InvalidOptionException("item was not bought or sold");
        } else {
            if (item.get().getLatestInstaSell().isPresent()) {
                return item.get().getLatestInstaSell().get().getPreTaxPrice();
            } else {
                throw new InvalidOptionException("item does not have an insta sell price");
            }
        }
    }

    private int latestSellCalculation(Optional<FlippingItem> item) throws InvalidOptionException {
        if (!item.isPresent()) {
            throw new InvalidOptionException("item was not bought or sold");
        } else {
            if (item.get().getLatestSell().isPresent()) {
                return item.get().getLatestSell().get().getPreTaxPrice();
            } else {
                throw new InvalidOptionException("item does not have a sell");
            }
        }
    }

    private int latestBuyCalculation(Optional<FlippingItem> item) throws InvalidOptionException {
        if (!item.isPresent()) {
            throw new InvalidOptionException("item was not bought or sold");
        } else {
            if (item.get().getLatestBuy().isPresent()) {
                return item.get().getLatestBuy().get().getPrice();
            } else {
                throw new InvalidOptionException("item does not have a buy");
            }
        }
    }

    private int applyModifier(String modifier, int value) throws InvalidOptionException {
        if (modifier.length() < 2) {
            throw new InvalidOptionException("Modifier has to be one of +,-,*, followed by a positive number. Example: +2, -5, *9");
        }

        float num = 0;
        try {
            num = Float.parseFloat(modifier.substring(1));
            if (num < 0) {
                throw new InvalidOptionException("Modifier has to be one of +,-,*, followed by a positive number. Example: +2, -5, *9");
            }
        } catch (NumberFormatException e) {
            throw new InvalidOptionException("Modifier has to be one of +,-,*, followed by a positive number. Example: +2, -5, *9");
        }

        char operator = modifier.charAt(0);
        switch (operator) {
            case '-':
                return Math.round(value - num);
            case '+':
                return Math.round(value + num);
            case '*':
                return Math.round(value * num);
            default:
                throw new InvalidOptionException("Modifier has to be one of +,-,*, followed by a positive number. Example: +2, -5, *9");
        }
    }

    private int getCashStackInInv() {
        ItemContainer inventory = plugin.getClient().getItemContainer(InventoryID.INV);
        if (inventory == null) {
            return 0;
        }
        Item[] inventoryItems = inventory.getItems();
        for (Item item : inventoryItems) {
            if (item.getId() == ItemID.COINS) {
                return item.getQuantity();
            }
        }
        return 0;
    }

}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
